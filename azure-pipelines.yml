trigger: none 
#  branches:
#    include:
#      - main

pr:
  branches:
    include:
      - main

pool:
  name: Self-Hosted   

variables:
  DB_SERVER: 'localhost'
  DB_NAME: 'Payroll'
  FLYWAY_CONFIG_PATH: '$(Build.SourcesDirectory)/Database/MSSQL_Server/Dev/conf/flyway-dev.conf' 
  REPO_URL: 'https://github.com/ktsreddy007/DB_Migrotron' 
  REPO_FOLDER: 'Database/MSSQL_Server/Dev/rollback_sql'
  LOG_FOLDER: 'E:/DevOpsLogs'
  LOG_FILE: '$(LOG_FOLDER)/MigrationLog.txt'
  TABLES_FILE: '$(LOG_FOLDER)/UsedTables.txt'


stages:
  - stage: CaptureRollbackScripts
    condition: eq(variables['Build.Reason'], 'PullRequest')
    displayName: 'Capture Rollback Scripts and Insert into Mapper Table'
    jobs:
      - job: DB_Migrator
        steps:
          - checkout: self
            persistCredentials: true
            fetchDepth: 0
          - task: PowerShell@2
            displayName: 'File Capture and Insertor'
            inputs:
              targetType: 'inline'
              script: |
                try {
                      $prId = "$(System.PullRequest.PullRequestId)"
                      if (-not $prId) {
                          Write-Host "PR ID not available. Exiting stage."
                          exit 0
                        }
                      Write-Host "PR ID detected: $prId"
                      $sourceBranch = "$(System.PullRequest.SourceBranch)"
                      $sourceBranchName = $sourceBranch -replace 'refs/heads/', ''
                      Write-Host "Source branch: $sourceBranchName"
                      git fetch origin +refs/heads/*:refs/remotes/origin/*
                      $changedFilesRaw = git diff --diff-filter=AMCR --name-only origin/main origin/$sourceBranchName
                      Write-Host "Raw changed files:`n$changedFilesRaw"
                      $changedFiles = $changedFilesRaw -split "`n" | Where-Object { $_ -ne "" }
                      Write-Host "Filtered changed files:`n$($changedFiles -join "`n")" 
                      if (-not $changedFiles -or $changedFiles.Count -eq 0) {
                            Write-Host "No changed files detected. Exiting."
                            exit 0
                      }
                      $rollbackScripts = $changedFiles | Where-Object { $_ -like "*Database/MSSQL_Server/Dev/rollback_sql/*.sql" }
                      Write-Host "Rollback scripts detected:`n$($rollbackScripts -join "`n")" 
                      if (-not $rollbackScripts -or $rollbackScripts.Count -eq 0) {
                            Write-Host "No rollback scripts found. Exiting job."
                            exit 0
                      }
                      Write-Host "Connecting to DB server: $(DB_SERVER), Database: $(DB_NAME)"      
                      [System.Reflection.Assembly]::LoadWithPartialName("System.Data.SqlClient") | Out-Null
                      $connectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$env:dbUser;Password=$env:dbPassword;"
                      $connection = New-Object System.Data.SqlClient.SqlConnection
                      $connection.ConnectionString = $connectionString
                      $connection.Open()
                      Write-Host "DB connection opened."
                      foreach ($scriptPath in $rollbackScripts) {
                          $scriptName = [System.IO.Path]::GetFileName($scriptPath)
                          Write-Host "Inserting rollback script: $scriptName"
                          $command = $connection.CreateCommand()
                          $command.CommandText = "INSERT INTO Payroll.dbo.migration_rollback_mapper (rollback_script_name, rollback_script_repo_folder, rollback_script_repo_url, build_id, pr_id) VALUES (@scriptName, @repoFolder, @repoUrl, @buildId, @prId)"
                          $command.Parameters.AddWithValue("@scriptName", $scriptName) | Out-Null
                          $command.Parameters.AddWithValue("@repoFolder", "$(REPO_FOLDER)") | Out-Null
                          $command.Parameters.AddWithValue("@repoUrl", "$(REPO_URL)") | Out-Null
                          $command.Parameters.AddWithValue("@buildId", "$(Build.BuildId)") | Out-Null
                          $command.Parameters.AddWithValue("@prId", $prId) | Out-Null
                          $command.ExecuteNonQuery()
                          Write-Host "Inserted into DB: $scriptName"
                    }
                    $connection.Close()
                } catch {
                    Write-Error "An error occurred: $_"
                    exit 1
                }      
            env:
                dbUser: $(dbUser)
                dbPassword: $(dbPassword)
###################################################################################
  - stage: PrepareEnvironment
    dependsOn: CaptureRollbackScripts
    condition: succeeded()
    displayName: 'Prepare Environment'
    jobs:
      - job: SetupTools
        steps:
          - task: PowerShell@2
            displayName: 'Check and Install Java (via command only)'
            inputs:
              targetType: 'inline'
              script: |
                if (Get-Command java -ErrorAction SilentlyContinue) {
                  Write-Host "Java is already installed."
                } else {
                  Write-Host "Java is NOT installed. Installing OpenJDK 11..."
                  choco install -y openjdk11
                }
          - task: PowerShell@2
            displayName: 'Check and Install Flyway CLI (any version)'
            inputs:
              targetType: 'inline'
              script: |
                if (Get-Command flyway -ErrorAction SilentlyContinue) {
                  Write-Host "Flyway CLI is already installed."
                } else {
                    Write-Host "Flyway CLI is NOT installed. Installing..."
                    $flywayZip = "$(Build.SourcesDirectory)\flyway.zip"
                    Invoke-WebRequest -Uri "https://repo1.maven.org/maven2/org/flywaydb/flyway-commandline/9.8.1/flyway-commandline-9.8.1-windows-x64.zip" -OutFile $flywayZip
                    Expand-Archive -Path $flywayZip -DestinationPath "$(Build.SourcesDirectory)\flyway"
                    $flywayPath = "$(Build.SourcesDirectory)\flyway\flyway-9.8.1"
                    $env:Path = "$flywayPath;$env:Path"
                    Write-Host "Flyway CLI installed successfully."
                  }
######################################################
  - stage: FlywayValidation
    dependsOn: PrepareEnvironment
    condition: succeeded()
    displayName: 'Flyway Validate and Info'
    jobs:
      - job: ValidateFlyway
        steps:
          - task: PowerShell@2
            displayName: 'Conditional Flyway Validate (skip on fresh DB)'
            inputs:
              targetType: 'inline'
              script: |
                $connectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$(dbUser);Password=$(dbPassword);"
                [System.Reflection.Assembly]::LoadWithPartialName("System.Data.SqlClient") | Out-Null
                $connection = New-Object System.Data.SqlClient.SqlConnection
                $connection.ConnectionString = $connectionString
                $connection.Open()
                $query = "SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'flyway_schema_history'"
                $command = $connection.CreateCommand()
                $command.CommandText = $query
                $tableExists = $command.ExecuteScalar()
                $connection.Close()
                Write-Host "Using Flyway config file at path: $(FLYWAY_CONFIG_PATH)"
                if ($tableExists -gt 0) {
                    Write-Host "flyway_schema_history table found. Proceeding with flyway validate."
                    & flyway validate "-ignoreMigrationPatterns=*:pending" "-configFiles=$(FLYWAY_CONFIG_PATH)"
                    if ($LASTEXITCODE -ne 0) {
                            Write-Error "Flyway validate failed."
                            exit 1
                    }
                } else {
                    Write-Host "flyway_schema_history table NOT found. Skiping flyway validate for fresh DB."
                } 
            env:
              dbUser: $(dbUser)
              dbPassword: $(dbPassword)     
          - task: PowerShell@2
            displayName: 'Flyway Info (Dry Run)'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Using Flyway config file at path: $(FLYWAY_CONFIG_PATH)"
                & flyway info "-configFiles=$(FLYWAY_CONFIG_PATH)"
                if ($LASTEXITCODE -ne 0) {
                      Write-Error "Flyway info command failed."
                      exit 1
                }                 
######################################################
  - stage: SQL_Linting
    displayName: "SQL_Syntax_Checker"
    dependsOn: FlywayValidation
    condition: succeeded()
    jobs:
     - job: SQL_Linting
       steps:
       - script: echo "This is a dummy stage for future use."
######################################################
  - stage: Premigration_SQLLogger
    displayName: "Pre_SQL_Logger"
    dependsOn: SQL_Linting
    condition: succeeded()
    jobs:
     - job: PreSQL_Logger
       steps:
          - checkout: self
            persistCredentials: true
            fetchDepth: 0
          - task: PowerShell@2
            displayName: 'Pre-Migration Table Record Logger'
            inputs:
              targetType: 'inline'
              script: |
                $logFolder = "$(LOG_FOLDER)"
                $logFile = "$(LOG_FILE)"
                $tablesFile = "$(TABLES_FILE)"
                if (-not (Test-Path $logFolder)) {
                    New-Item -Path $logFolder -ItemType Directory | Out-Null
                }
                $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                $prId = "$(System.PullRequest.PullRequestId)"
                $sourceBranch = "$(System.PullRequest.SourceBranch)"
                $sourceBranchName = $sourceBranch -replace 'refs/heads/', ''
                git fetch origin
                $changedFilesRaw = git diff --diff-filter=AMCR --name-only origin/main origin/$sourceBranchName
                $changedFiles = $changedFilesRaw -split "`n" | Where-Object { $_ -like "*.sql" }
                $filteredFiles = $changedFiles | Where-Object { $_ -like "*Database/MSSQL_Server/Dev/migrations/*" }
                $filteredFiles | ForEach-Object { Write-Host " - $_" }

                $tableNames = @()
                foreach ($file in $filteredFiles) {
                        $fullPath = Join-Path -Path "$(Build.SourcesDirectory)" -ChildPath $file
                        if (Test-Path $fullPath) {
                            Write-Host "Processing file: $fullPath"
                            $matches = Get-Content $fullPath |
                            Select-String -Pattern "(?i)(create\s+table|insert\s+into)\s+((\[[^\]]+\]|\w+)\.)*((\[[^\]]+\]|\w+))" -AllMatches
                            foreach ($matchInfo in $matches) {
                                  foreach ($match in $matchInfo.Matches) {
                                      $fullMatch = $match.Value  
                                      $parts = $fullMatch -split '\.'
                                      $table = $parts[-1] -replace '\[|\]', ''
                                      if ($table -and -not ($tableNames -contains $table)) {
                                          $tableNames += $table
                                          Write-Host "  â†’ Found table: $table"
                                      }
                                  }
                            }          
                        } else {
                            Write-Host "File not found: $fullPath"
                          }
                        }
                if ($tableNames.Count -eq 0) {
                      Write-Host "No tables extracted from migration files."
                    } else {
                    $tableNames | Out-File -FilePath $tablesFile -Encoding utf8
                }
                Add-Content -Path $logFile -Value "=====BEFORE RECORD COUNT====="
                Add-Content -Path $logFile -Value "RunID: $(Build.BuildId)"
                foreach ($table in $tableNames) {
                  try {
                        $schema = "dbo"
                        $tableName = $table
                        if ($table -match "^\[(.+?)\]\.\[(.+?)\]$") {
                            $schema = $matches[1]
                            $tableName = $matches[2]
                        } elseif ($table -match "^(.+?)\.(.+?)$") {
                            $schema = $matches[1]
                            $tableName = $matches[2]
                          }
                        $query = "IF OBJECT_ID('$schema.$tableName', 'U') IS NOT NULL SELECT COUNT(*) FROM [$schema].[$tableName] ELSE SELECT -1"
                        $connectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$env:dbUser;Password=$env:dbPassword;"
                        $connection = New-Object System.Data.SqlClient.SqlConnection($connectionString)
                        $command = $connection.CreateCommand()
                        $command.CommandText = $query
                        $connection.Open()
                        $count = $command.ExecuteScalar()
                        $connection.Close()
                        
                        if ($count -eq -1) {
                          Add-Content -Path $logFile -Value "TableName : $table"
                          Add-Content -Path $logFile -Value "RecordsCount : No Table / New Table"
                        } else {
                          Add-Content -Path $logFile -Value "TableName : $table"
                          Add-Content -Path $logFile -Value "RecordsCount : $count" 
                          }
                        Add-Content -Path $logFile -Value "Timestamp : $timestamp`n"
                        Write-Host "Table: $table | Records: $(if ($count -eq -1) {'No Table / New Table'} else {$count})"
                      } catch {
                          Write-Host "Unexpected error checking table [$table]: $($_.Exception.Message)"
                          Add-Content -Path $logFile -Value "TableName : $table"
                          Add-Content -Path $logFile -Value "RecordsCount : Error - $($_.Exception.Message)"
                          Add-Content -Path $logFile -Value "Timestamp : $timestamp`n"
                        }
                    }
                  Add-Content -Path $logFile -Value "======MIGRATION START ==============="
            env:
              dbUser: $(dbUser)
              dbPassword: $(dbPassword)       
#######################################################
  - stage: Rollback_Finder
    dependsOn: Premigration_SQLLogger
    condition: succeeded()
    displayName: "Rollback Scripts Existence"
    jobs:
      - job: RollbackCheck
        steps:
          - task: PowerShell@2
            displayName: 'Check if Rollback Script Exists for this PR'
            inputs:
                targetType: 'inline'
                script: |
                    $prId = "$(System.PullRequest.PullRequestId)"
                    Write-Host "Checking rollback scripts for PR ID: $prId"
                    $connectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$env:dbUser;Password=$env:dbPassword;"
                    [System.Reflection.Assembly]::LoadWithPartialName("System.Data.SqlClient") | Out-Null
                    $connection = New-Object System.Data.SqlClient.SqlConnection
                    $connection.ConnectionString = $connectionString
                    $connection.Open()
                    $query = "SELECT COUNT(*) FROM Payroll.dbo.migration_rollback_mapper WHERE pr_id = @prId AND rollback_script_name IS NOT NULL AND LTRIM(RTRIM(rollback_script_name)) <> ''"
                    $command = $connection.CreateCommand()
                    $command.CommandText = $query
                    $command.Parameters.AddWithValue("@prId", $prId) | Out-Null
                    $rollbackCount = $command.ExecuteScalar()
                    if ($rollbackCount -eq 0) {
                          Write-Host "No valid rollback scripts found for PR $prId. Failing pipeline."
                          $deleteCommand = $connection.CreateCommand()
                          $deleteQuery = "DELETE FROM Payroll.dbo.migration_rollback_mapper WHERE pr_id = @prId"
                          $deleteCommand.Parameters.AddWithValue("@prId", $prId) | Out-Null
                          $deleted = $deleteCommand.ExecuteNonQuery()
                          Write-Host "Deleted $deleted invalid rollback record(s) for PR ID $prId."
                          $connection.Close()
                          exit 1
                        } else {
                         Write-Host "Valid Rollback script(s) found: $rollbackCount for PR $prId. Proceeding to merge."
                         $connection.Close()
                    }
            env:
              dbUser: $(dbUser)
              dbPassword: $(dbPassword)
###############################################################             
  - stage: Flyway_Migration
    dependsOn: Rollback_Finder
    condition: succeeded()
    displayName: 'Migrating the Scripts'
    jobs:
      - job: FlywayMigrate
        steps:
          - task: PowerShell@2
            displayName: 'Run Flyway Migrate'
            inputs:
              targetType: 'inline'
              script: |
               Write-Host "Flyway migrate triggered on merge/push to main branch."
               & flyway migrate "-configFiles=$(FLYWAY_CONFIG_PATH)"
               if ($LASTEXITCODE -ne 0) {
                  Write-Error "Flyway migrate failed."
                  exit 1
                }
                Write-Host "Flyway migrate completed successfully."
            env:
              dbUser: $(dbUser)
              dbPassword: $(dbPassword)
###################################################################
#  - stage: Postmigration_SQLLogger
#    displayName: "Post_SQL_Logger"
#    jobs:
#     - job: PostSQL_Logger
#       steps:
#         - task: PowerShell@2
#           displayName: 'Post-Migration Table Record Logger'
#           inputs:
#              targetType: 'inline'
#              script: |
#                $logFile = "$(LOG_FILE)"
#                $tablesFile = "$(TABLES_FILE)"
#                $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
#                Add-Content -Path $logFile -Value "=====AFTER RECORD COUNT====="
#                Add-Content -Path $logFile -Value "RunID: $(Build.BuildId)"
#                if (-Not (Test-Path $tablesFile)) {
#                    Write-Error "UsedTables.txt not found. Cannot continue."
#                    exit 1
#                }
#                $tableNames = Get-Content $tablesFile | Sort-Object -Unique
#                foreach ($table in $tableNames) {
#                    try {
#                        $query = "SELECT COUNT(*) FROM [$table]"
#                        $connectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$env:dbUser;Password=$env:dbPassword;"
#                        $connection = New-Object System.Data.SqlClient.SqlConnection($connectionString)
#                        $command = $connection.CreateCommand()
#                        $command.CommandText = $query
#                        $connection.Open()
#                        $count = $command.ExecuteScalar()
#                        $connection.Close()
#                        Add-Content -Path $logFile -Value "TableName : $table"
#                        Add-Content -Path $logFile -Value "RecordsCount : $count"
#                        Add-Content -Path $logFile -Value "Timestamp : $timestamp`n"
#                      } catch {
#                        $err = $_.Exception.Message
#                        Write-Host "Error fetching data for table ${table}: $_"
#                      }
#                    }
#                Add-Content -Path $logFile -Value "=========MIGRATION COMPLETE =========`n"
#           env:
#             dbUser: $(dbUser)
#             dbPassword: $(dbPassword)
###################################################################
  - stage: Mappertb_updater
    displayName: "Migration_Rollback_Updater"
    dependsOn: Flyway_Migration
    condition: succeeded()
    jobs:
     - job: Updating_Mapper_Table
       steps:
        - task: PowerShell@2
          displayName: 'Update Migration Version and Script in Mapper Table'
          inputs:
              targetType: 'inline'
              script: |
                try {
                  $connectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$(dbUser);Password=$(dbPassword);"
                  [System.Reflection.Assembly]::LoadWithPartialName("System.Data.SqlClient") | Out-Null
                  $connection = New-Object System.Data.SqlClient.SqlConnection
                  $connection.ConnectionString = $connectionString
                  $connection.Open()
                  $prId = "$(System.PullRequest.PullRequestId)"
                  $buildId = "$(Build.BuildId)"
                  $getRollbackCmd = $connection.CreateCommand()
                  $getRollbackCmd.CommandText = "SELECT rollback_script_name FROM Payroll.dbo.migration_rollback_mapper WHERE pr_id = @prId AND build_id = @buildId"
                  $getRollbackCmd.Parameters.AddWithValue("@prId", $prId) | Out-Null
                  $getRollbackCmd.Parameters.AddWithValue("@buildId", $buildId) | Out-Null
                  
                  $reader = $getRollbackCmd.ExecuteReader()
                  $rollbackScripts = @()
                  while ($reader.Read()) {
                      $rollbackScripts += $reader["rollback_script_name"]
                  }
                  $reader.Close()
                  foreach ($rollbackFile in $rollbackScripts) {
                    $baseName = [System.IO.Path]::GetFileNameWithoutExtension($rollbackFile).ToLower() -replace "^rb__",""
                    $migrationCmd = $connection.CreateCommand()
                    $migrationCmd.CommandText = "SELECT TOP 1 version, script FROM flyway_schema_history WHERE success = 1 AND script COLLATE SQL_Latin1_General_CP1_CI_AS LIKE '%__' + @baseName + '.sql' ORDER BY installed_on DESC"
                    $migrationCmd.Parameters.AddWithValue("@baseName", $baseName) | Out-Null
                    $migrationReader = $migrationCmd.ExecuteReader()
                    if ($migrationReader.Read()) {
                        $version = $migrationReader["version"]
                        $script = $migrationReader["script"]
                        $migrationReader.Close()
                        $updateCmd = $connection.CreateCommand()
                        $updateCmd.CommandText = "UPDATE Payroll.dbo.migration_rollback_mapper SET migration_version = @version, migration_script = @script WHERE pr_id = @prId AND build_id = @buildId AND rollback_script_name = @rollbackName"
                        $updateCmd.Parameters.AddWithValue("@version", $version) | Out-Null
                        $updateCmd.Parameters.AddWithValue("@script", $script) | Out-Null
                        $updateCmd.Parameters.AddWithValue("@prId", $prId) | Out-Null
                        $updateCmd.Parameters.AddWithValue("@buildId", $buildId) | Out-Null
                        $updateCmd.Parameters.AddWithValue("@rollbackName", $rollbackFile) | Out-Null
                        $updated = $updateCmd.ExecuteNonQuery()
                        Write-Host "Updated $updated record(s) for '$rollbackFile' with version '$version'"
                    } else {
                        $migrationReader.Close()
                        Write-Host "No migration found for rollback script '$rollbackFile'"
                      }
                }
                $connection.Close()
                } catch {
                    Write-Error "Error updating rollback mapper: $_"
                    exit 1
                }             
          env:
              dbUser: $(dbUser)
              dbPassword: $(dbPassword)
###################################################################
  - stage: Postmigration_Flyway_Validator
    dependsOn: Flyway_Migration
    condition: succeeded()
    displayName: "Post_Flyway_Validator"
    jobs:
      - job: PostFlyway_Validator
        steps:
          - task: PowerShell@2
            displayName: 'Flyway Validate (Post Migration Consistency Check)'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Validating Flyway consistency after migration."
                & flyway validate "-configFiles=$(FLYWAY_CONFIG_PATH)"
                if ($LASTEXITCODE -ne 0) {
                    Write-Error "Flyway validation failed. Database and scripts may be inconsistent!"
                    exit 1
                }
            env:
              dbUser: $(dbUser)
              dbPassword: $(dbPassword)
         
