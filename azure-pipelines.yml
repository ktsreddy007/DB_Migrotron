trigger: none 
#  branches:
#    include:
#      - main

#pr:
#  branches:
#    include:
#     - main
      
pool:
  name: Self-Hosted   

variables:
  DB_SERVER: 'localhost'
  DB_NAME: 'Payroll'
  FLYWAY_CONFIG_PATH: '$(Build.SourcesDirectory)/Database/MSSQL_Server/Dev/conf/flyway-dev.conf' 
  REPO_URL: 'https://github.com/ktsreddy007/DB_Migrotron' 
  REPO_FOLDER: 'Database/MSSQL_Server/Dev/rollback_sql'
  LOG_FOLDER: 'B:\Pre_Post_SQL_Logs'
  LOG_FILE: '$(LOG_FOLDER)/Migration_Logs.txt'
  TABLES_FILE: '$(LOG_FOLDER)/Tables_list.txt'
#  SQL_FLUFF_CONFIG: '$(Build.SourcesDirectory)/Database/MSSQL_Server/Dev/.sqlfluff'
#  SQL_FLUFFS_REPORTS: 'B:\SQLFluff_Reports'
#  SQL_FLUFF_OUTPUT_FILE: '$(SQL_FLUFFS_REPORTS)/sqlfluff_pr_$(System.PullRequest.PullRequestId).json'

stages:
  - stage: CaptureRollbackScripts
    condition: eq(variables['Build.Reason'], 'PullRequest')
    displayName: 'Capture Rollback Scripts and Insert into Mapper Table'
    jobs:
      - job: RollbackScripts_Recorder
        steps:
          - checkout: self
            persistCredentials: true
            fetchDepth: 0
          - task: PowerShell@2
            displayName: 'File Capture and Insertor'
            inputs:
              targetType: 'inline'
              script: |
                try {
                      $prId = "$(System.PullRequest.PullRequestId)"
                      if (-not $prId) {
                          Write-Host "PR ID not available. Exiting stage."
                          exit 0
                        }
                      Write-Host "PR ID detected: $prId"
                      $sourceBranch = "$(System.PullRequest.SourceBranch)"
                      $sourceBranchName = $sourceBranch -replace 'refs/heads/', ''
                      Write-Host "Source branch: $sourceBranchName"
                      git fetch origin +refs/heads/*:refs/remotes/origin/*
                      $changedFilesRaw = git diff --diff-filter=AMCR --name-only origin/main origin/$sourceBranchName
                      Write-Host "Raw changed files:`n$changedFilesRaw"
                      $changedFiles = $changedFilesRaw -split "`n" | Where-Object { $_ -ne "" }
                      Write-Host "Filtered changed files:`n$($changedFiles -join "`n")" 
                      if (-not $changedFiles -or $changedFiles.Count -eq 0) {
                            Write-Host "No changed files detected. Exiting."
                            exit 0
                      }
                      $rollbackScripts = $changedFiles | Where-Object { $_ -like "*Database/MSSQL_Server/Dev/rollback_sql/*.sql" }
                      Write-Host "Rollback scripts detected:`n$($rollbackScripts -join "`n")" 
                      if (-not $rollbackScripts -or $rollbackScripts.Count -eq 0) {
                            Write-Host "No rollback scripts found. Exiting job."
                            exit 0
                      }
                      Write-Host "Connecting to DB server: $(DB_SERVER), Database: $(DB_NAME)"      
                      [System.Reflection.Assembly]::LoadWithPartialName("System.Data.SqlClient") | Out-Null
                      $connectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$env:dbUser;Password=$env:dbPassword;"
                      $connection = New-Object System.Data.SqlClient.SqlConnection
                      $connection.ConnectionString = $connectionString
                      $connection.Open()
                      Write-Host "DB connection opened."
                      foreach ($scriptPath in $rollbackScripts) {
                          $scriptName = [System.IO.Path]::GetFileName($scriptPath)
                          Write-Host "Processing rollback script: $scriptName"
                          if ($scriptName -notmatch "^RB__V\d+__.+\.sql$") {
                              Write-Error "Rollback script '$scriptName' does not follow naming convention 'RB__V<version>__<name>.sql'."
                              exit 1
                          }
                          Write-Host "Inserting rollback script: $scriptName"    
                          $command = $connection.CreateCommand()
                          $command.CommandText = "INSERT INTO Payroll.dbo.migration_rollback_mapper (rollback_script_name, rollback_script_repo_folder, rollback_script_repo_url, build_id, pr_id) VALUES (@scriptName, @repoFolder, @repoUrl, @buildId, @prId)"
                          $command.Parameters.AddWithValue("@scriptName", $scriptName) | Out-Null
                          $command.Parameters.AddWithValue("@repoFolder", "$(REPO_FOLDER)") | Out-Null
                          $command.Parameters.AddWithValue("@repoUrl", "$(REPO_URL)") | Out-Null
                          $command.Parameters.AddWithValue("@buildId", "$(Build.BuildId)") | Out-Null
                          $command.Parameters.AddWithValue("@prId", $prId) | Out-Null
                          $command.ExecuteNonQuery()
                          Write-Host "Inserted into DB: $scriptName"
                    }
                    $connection.Close()
                } catch {
                    Write-Error "An error occurred: $_"
                    exit 1
                }      
            env:
                dbUser: $(dbUser_1)
                dbPassword: $(dbPassword)
###################################################################################
  - stage: PrepareEnvironment
    dependsOn: CaptureRollbackScripts
    condition: succeeded()
    displayName: 'Prepare Environment'
    jobs:
      - job: SetupTools
        steps:
          - task: PowerShell@2
            displayName: 'Check and Install Java (via command only)'
            inputs:
              targetType: 'inline'
              script: |
                if (Get-Command java -ErrorAction SilentlyContinue) {
                  Write-Host "Java is already installed."
                } else {
                  Write-Host "Java is NOT installed. Installing OpenJDK 11..."
                  choco install -y openjdk11
                }
          - task: PowerShell@2
            displayName: 'Check and Install Flyway CLI (any version)'
            inputs:
              targetType: 'inline'
              script: |
                if (Get-Command flyway -ErrorAction SilentlyContinue) {
                  Write-Host "Flyway CLI is already installed."
                } else {
                    Write-Host "Flyway CLI is NOT installed. Installing..."
                    $flywayZip = "$(Build.SourcesDirectory)\flyway.zip"
                    Invoke-WebRequest -Uri "https://repo1.maven.org/maven2/org/flywaydb/flyway-commandline/9.8.1/flyway-commandline-9.8.1-windows-x64.zip" -OutFile $flywayZip
                    Expand-Archive -Path $flywayZip -DestinationPath "$(Build.SourcesDirectory)\flyway"
                    $flywayPath = "$(Build.SourcesDirectory)\flyway\flyway-9.8.1"
                    $env:Path = "$flywayPath;$env:Path"
                    Write-Host "Flyway CLI installed successfully."
                  }
#         - task: PowerShell@2
#           displayName: 'Check and Install Python'
#           inputs:
#             targetType: 'inline'
#             script: |
#               $pythonPath = "C:\Program Files\Python313\python.exe"
#               if (-Not (Test-Path $pythonPath)) {
#                 Write-Error "Python not found at $pythonPath. Please install Python system-wide."
#                  exit 1
#                }
#                Write-Host "Python found at $pythonPath"
#               & "$pythonPath" --version
#          - task: PowerShell@2
#            displayName: 'Check and Install SQLFluff'
#            inputs:
#              targetType: 'inline'
#              script: |
#                $pythonPath = "C:\Program Files\Python313\python.exe"
#                $sqlfluffPath = "C:\Program Files\Python313\Scripts\sqlfluff.exe"
#                if (-Not (Test-Path $sqlfluffPath)) {
#                  Write-Host "sqlfluff not found. Installing via pip..."
#                  & "$pythonPath" -m pip install sqlfluff
#                } else {
#                    Write-Host "sqlfluff is already installed at $sqlfluffPath"
#                  }
#                Write-Host "sqlfluff version:"
#                & "$sqlfluffPath" --version      
######################################################
#  - stage: SQL_Linting
#    displayName: "SQL_Syntax_Checker"
#    dependsOn: PrepareEnvironment
#    condition: succeeded()
#    jobs:
#     - job: Run_SQLFluff_Lint
#       steps:
#        - task: PowerShell@2
#          displayName: "Run SQLFluff Lint"
#          inputs:
#            targetType: 'inline'
#            script: |
#              $sqlfluffPath = "C:\Program Files\Python313\Scripts\sqlfluff.exe"
#              New-Item -ItemType Directory -Force -Path "$(SQL_FLUFFS_REPORTS)"
#              git fetch origin $(System.PullRequest.TargetBranch)

#              $diffFiles = git diff --name-only origin/$(System.PullRequest.TargetBranch) HEAD
#              $changedFiles = $diffFiles | Where-Object { $_.ToLower().EndsWith(".sql") }
#              if (-not $changedFiles -or $changedFiles.Count -eq 0) {
#                Write-Host "##[section]No SQL files changed in this PR. Skipping linting."
#                Exit 0
#              }
#              Write-Host "##[section]Changed SQL Files:"
#              $changedFiles | ForEach-Object { Write-Host $_ }

#              $outputFile = "$(SQL_FLUFF_OUTPUT_FILE)"
#              $jsonOutputFile = "$(SQL_FLUFFS_REPORTS)"
#              $lintErrors = 0
#              foreach ($file in $changedFiles) {
#                  Write-Host "Linting file: $file"
#                  (& "$sqlfluffPath" lint $file --config "$(SQL_FLUFF_CONFIG)" --format json) | Out-File -Append -Encoding utf8 $jsonOutputFile
#                  if ($LASTEXITCODE -ne 0) {
#                    $lintErrors++
#                  }
#              }
#              if ($lintErrors -gt 0) {
#                  Write-Host "##vso[task.complete result=SucceededWithIssues;]SQLFluff found linting issues."
#              } else {
#                  Write-Host "##[section]SQLFluff: No linting issues found."
#                }                        
######################################################
  - stage: Pre_FlywayValidator
    dependsOn: PrepareEnvironment
    condition: succeeded()
    displayName: 'Flyway Validate and Info'
    jobs:
      - job: ValidateFlyway
        steps:
          - task: PowerShell@2
            displayName: 'Conditional Flyway Validate (skip on fresh DB)'
            inputs:
              targetType: 'inline'
              script: |
                $env:FLYWAY_USER = $env:dbUser
                $env:FLYWAY_PASSWORD = $env:dbPassword

                $connectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$env:dbUser;Password=$env:dbPassword;"
                [System.Reflection.Assembly]::LoadWithPartialName("System.Data.SqlClient") | Out-Null
                $connection = New-Object System.Data.SqlClient.SqlConnection
                $connection.ConnectionString = $connectionString
                $connection.Open()
                $query = "SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'flyway_schema_history'"
                $command = $connection.CreateCommand()
                $command.CommandText = $query
                $tableExists = $command.ExecuteScalar()
                $connection.Close()
                Write-Host "Using Flyway config file at path: $(FLYWAY_CONFIG_PATH)"
                if ($tableExists -gt 0) {
                    Write-Host "flyway_schema_history table found. Proceeding with flyway validate."
                    & flyway validate "-ignoreMigrationPatterns=*:pending" "-configFiles=$(FLYWAY_CONFIG_PATH)"
                    if ($LASTEXITCODE -ne 0) {
                            Write-Error "Flyway validate failed."
                            exit 1
                    }
                } else {
                    Write-Host "flyway_schema_history table NOT found so Skiping flyway validate for fresh DB."
                } 
            env:
              dbUser: $(dbUser_1)
              dbPassword: $(dbPassword)     
          - task: PowerShell@2
            displayName: 'Flyway Info (Dry Run)'
            inputs:
              targetType: 'inline'
              script: |
                $env:FLYWAY_USER = $env:dbUser
                $env:FLYWAY_PASSWORD = $env:dbPassword

                Write-Host "Using Flyway config file at path: $(FLYWAY_CONFIG_PATH)"
                & flyway info "-configFiles=$(FLYWAY_CONFIG_PATH)"
                if ($LASTEXITCODE -ne 0) {
                      Write-Error "Flyway info command failed."
                      exit 1
                }
            env:
              dbUser: $(dbUser_1)
              dbPassword: $(dbPassword)  
###############################################################                            
  - stage: Premigration_SQLLogger
    displayName: "Pre_SQL_Logger"
    dependsOn: Pre_FlywayValidator
    condition: succeeded()
    jobs:
     - job: PreSQL_Logger
       steps:
          - checkout: self
            persistCredentials: true
            fetchDepth: 0
          - task: PowerShell@2
            displayName: 'Pre-Migration Table Record Logger'
            inputs:
              targetType: 'inline'
              script: |
                $logFolder = "$(LOG_FOLDER)"
                $logFile = "$(LOG_FILE)"
                $tablesFile = "$(TABLES_FILE)"
                if (-not (Test-Path $logFolder)) {
                    New-Item -Path $logFolder -ItemType Directory | Out-Null
                }
                $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                $prId = "$(System.PullRequest.PullRequestId)"
                $sourceBranch = "$(System.PullRequest.SourceBranch)"
                $sourceBranchName = $sourceBranch -replace 'refs/heads/', ''
                git fetch origin
                $changedFilesRaw = git diff --diff-filter=AMCR --name-only origin/main origin/$sourceBranchName
                $changedFiles = $changedFilesRaw -split "`n" | Where-Object { $_ -like "*.sql" }
                $filteredFiles = $changedFiles | Where-Object { $_ -like "*Database/MSSQL_Server/Dev/migrations/*" }
                $filteredFiles | ForEach-Object { Write-Host " - $_" }

                $tableNames = @()
                foreach ($file in $filteredFiles) {
                        $fullPath = Join-Path -Path "$(Build.SourcesDirectory)" -ChildPath $file
                        if (Test-Path $fullPath) {
                            Write-Host "Processing file: $fullPath"
                            Add-Content -Path $logFile -Value "Processed migration script: $file"
                            $matches = Get-Content $fullPath |
                            Select-String -Pattern "(?i)(create\s+table|insert\s+into)\s+((\[[^\]]+\]|\w+)\.)*((\[[^\]]+\]|\w+))" -AllMatches
                            foreach ($matchInfo in $matches) {
                                  foreach ($match in $matchInfo.Matches) {
                                      $fullMatch = $match.Value  
                                      $parts = $fullMatch -split '\.'
                                      $table = $parts[-1] -replace '\[|\]', ''
                                      if ($table -and -not ($tableNames -contains $table)) {
                                          $tableNames += $table
                                          Write-Host "  â†’ Found table: $table"
                                      }
                                  }
                            }          
                        } else {
                            Write-Host "File not found: $fullPath"
                          }
                        }
                if ($tableNames.Count -eq 0) {
                      Write-Host "No tables extracted from migration files."
                    } else {
                    $tableNames | Out-File -FilePath $tablesFile -Encoding utf8
                }
                Add-Content -Path $logFile -Value "=====BEFORE MIGRATION RECORD COUNT====="
                Add-Content -Path $logFile -Value "RunID: $(Build.BuildId)"
                foreach ($table in $tableNames) {
                  try {
                        $schema = "dbo"
                        $tableName = $table
                        if ($table -match "^\[(.+?)\]\.\[(.+?)\]$") {
                            $schema = $matches[1]
                            $tableName = $matches[2]
                        } elseif ($table -match "^(.+?)\.(.+?)$") {
                            $schema = $matches[1]
                            $tableName = $matches[2]
                          }
                        $query = "IF OBJECT_ID('$schema.$tableName', 'U') IS NOT NULL SELECT COUNT(*) FROM [$schema].[$tableName] ELSE SELECT -1"
                        $connectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$env:dbUser;Password=$env:dbPassword;"
                        $connection = New-Object System.Data.SqlClient.SqlConnection($connectionString)
                        $command = $connection.CreateCommand()
                        $command.CommandText = $query
                        $connection.Open()
                        $count = $command.ExecuteScalar()
                        $connection.Close()
                        
                        if ($count -eq -1) {
                          Add-Content -Path $logFile -Value "TableName : $table"
                          Add-Content -Path $logFile -Value "RecordsCount : No Table / New Table"
                        } else {
                          Add-Content -Path $logFile -Value "TableName : $table"
                          Add-Content -Path $logFile -Value "RecordsCount : $count" 
                          }
                        Add-Content -Path $logFile -Value "Timestamp : $timestamp`n"
                        Write-Host "Table: $table | Records: $(if ($count -eq -1) {'No Table / New Table'} else {$count})"
                      } catch {
                          Write-Host "Unexpected error checking table [$table]: $($_.Exception.Message)"
                          Add-Content -Path $logFile -Value "TableName : $table"
                          Add-Content -Path $logFile -Value "RecordsCount : Error - $($_.Exception.Message)"
                          Add-Content -Path $logFile -Value "Timestamp : $timestamp`n"
                        }
                    }
                  Add-Content -Path $logFile -Value "======MIGRATION START ==============="
            env:
              dbUser: $(dbUser_1)
              dbPassword: $(dbPassword)       
#######################################################
  - stage: Rollback_Finder
    dependsOn: Premigration_SQLLogger
    condition: succeeded()
    displayName: "Rollback Scripts Existence"
    jobs:
      - job: RollbackCheck
        steps:
          - task: PowerShell@2
            displayName: 'Check if Rollback Script Exists for this PR'
            inputs:
                targetType: 'inline'
                script: |
                    $prId = "$(System.PullRequest.PullRequestId)"
                    Write-Host "Checking rollback scripts for PR ID: $prId"
                    $connectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$env:dbUser;Password=$env:dbPassword;"
                    [System.Reflection.Assembly]::LoadWithPartialName("System.Data.SqlClient") | Out-Null
                    $connection = New-Object System.Data.SqlClient.SqlConnection
                    $connection.ConnectionString = $connectionString
                    $connection.Open()
                    $query = "SELECT COUNT(*) FROM Payroll.dbo.migration_rollback_mapper WHERE pr_id = @prId AND rollback_script_name IS NOT NULL AND LTRIM(RTRIM(rollback_script_name)) <> ''"
                    $command = $connection.CreateCommand()
                    $command.CommandText = $query
                    $command.Parameters.AddWithValue("@prId", $prId) | Out-Null
                    $rollbackCount = $command.ExecuteScalar()
                    if ($rollbackCount -eq 0) {
                          Write-Host "No valid rollback scripts found for PR $prId. Failing pipeline."
                          $deleteCommand = $connection.CreateCommand()
                          $deleteQuery = "DELETE FROM Payroll.dbo.migration_rollback_mapper WHERE pr_id = @prId"
                          $deleteCommand.Parameters.AddWithValue("@prId", $prId) | Out-Null
                          $deleted = $deleteCommand.ExecuteNonQuery()
                          Write-Host "Deleted $deleted invalid rollback record(s) for PR ID $prId."
                          $connection.Close()
                          exit 1
                        } else {
                         Write-Host "Valid Rollback script(s) found: $rollbackCount for PR $prId. Proceeding to merge."
                         $connection.Close()
                    }
            env:
              dbUser: $(dbUser_1)
              dbPassword: $(dbPassword)
###############################################################             
  - stage: Flyway_Migration
    dependsOn: Rollback_Finder
    condition: succeeded()
    displayName: 'Migrating the Scripts'
    jobs:
      - job: FlywayMigrate
        steps:
          - task: PowerShell@2
            displayName: 'Run Flyway Migrate'
            inputs:
              targetType: 'inline'
              script: |
               Write-Host "Connecting to DB server: $(DB_SERVER), Database: $(DB_NAME)"
               [System.Reflection.Assembly]::LoadWithPartialName("System.Data.SqlClient") | Out-Null

               $dbUser = $env:dbUser
               $dbPassword = $env:dbPassword
               
               $env:FLYWAY_USER = $dbUser
               $env:FLYWAY_PASSWORD = $dbPassword

               $connectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$dbUser;Password=$dbPassword;"
               $connection = New-Object System.Data.SqlClient.SqlConnection
               $connection.ConnectionString = $connectionString
               $connection.Open()
               Write-Host "DB connection opened."

               $tableName = "flyway_schema_history"
               $sqlQuery = "SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = '$tableName'"
               $command = $connection.CreateCommand()
               $command.CommandText = $sqlQuery
               $tableCount = $command.ExecuteScalar()
               Write-Host "Table count result: $tableCount"    

               if ($tableCount -eq 0) {
                  Write-Host "Table '$tableName' does not exist."
                  Write-Host "Running flyway baseline before migrate with baselineVersion=0..."
                  & flyway -configFiles="$(FLYWAY_CONFIG_PATH)" baseline -baselineVersion=0
                  if ($LASTEXITCODE -ne 0) {
                    Write-Error "Flyway baseline failed."
                    $connection.Close()
                    exit 1
                  }
                }
                else {
                  Write-Host "Table '$tableName' exists."
                }
               Write-Host "Flyway migrate triggered on merge/push to main branch."
               & flyway -configFiles="$(FLYWAY_CONFIG_PATH)" migrate
               if ($LASTEXITCODE -ne 0) {
                  Write-Error "Flyway migrate failed."
                  $connection.Close()
                  exit 1
                }
               Write-Host "Flyway migrate completed successfully."
               $connection.Close()
            env:
              dbUser: $(dbUser_1)
              dbPassword: $(dbPassword)
###################################################################
  - stage: Postmigration_SQLLogger
    displayName: "Post_SQL_Logger"
    dependsOn: Flyway_Migration
    condition: succeeded()
    jobs:
     - job: PostSQL_Logger
       steps:
         - task: PowerShell@2
           displayName: 'Post-Migration Table Record Logger'
           inputs:
              targetType: 'inline'
              script: |
                $logFile = "$(LOG_FILE)"
                $tablesFile = "$(TABLES_FILE)"
                $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                Write-Host "Starting Post-Migration Logging..."
                if (-Not (Test-Path $tablesFile)) {
                    Write-Error "UsedTables.txt not found. Cannot continue."
                    exit 1
                }
                Add-Content -Path $logFile -Value "=====AFTER MIGRATION RECORD COUNT====="
                Add-Content -Path $logFile -Value "RunID: $(Build.BuildId)"
                $tableNames = Get-Content $tablesFile | Sort-Object -Unique
                foreach ($table in $tableNames) {
                    try {
                        $query = "SELECT COUNT(*) FROM [$table]"
                        $connectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$env:dbUser;Password=$env:dbPassword;"
                        $connection = New-Object System.Data.SqlClient.SqlConnection($connectionString)
                        $command = $connection.CreateCommand()
                        $command.CommandText = $query
                        $connection.Open()
                        $count = $command.ExecuteScalar()
                        $connection.Close()
                        Add-Content -Path $logFile -Value "TableName : $table"
                        Add-Content -Path $logFile -Value "RecordsCount : $count"
                        Add-Content -Path $logFile -Value "Timestamp : $timestamp`n"
                        Write-Host "Table: $table | Records: $count"
                      } catch {
                        Add-Content -Path $logFile -Value "TableName : $table"
                        Add-Content -Path $logFile -Value "RecordsCount : No Table / New Table"
                        Add-Content -Path $logFile -Value "Timestamp : $timestamp`n"
                        Write-Host "Table [$table] does not exist after migration."
                      }
                    }
                Add-Content -Path $logFile -Value "=========MIGRATION COMPLETE =========`n"
                Write-Host "Post-Migration Logging Completed."
           env:
             dbUser: $(dbUser_1)
             dbPassword: $(dbPassword)
###################################################################
  - stage: Mappertb_updater
    displayName: "Migration_Rollback_Updater"
    dependsOn: Flyway_Migration
    condition: succeeded()
    jobs:
     - job: Updating_Mapper_Table
       steps:
        - task: PowerShell@2
          displayName: 'Update Migration Version and Script in Mapper Table'
          inputs:
              targetType: 'inline'
              script: |
                try {
                    $connectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$env:dbUser;Password=$env:dbPassword;"
                    [System.Reflection.Assembly]::LoadWithPartialName("System.Data.SqlClient") | Out-Null
                    $connection = New-Object System.Data.SqlClient.SqlConnection
                    $connection.ConnectionString = $connectionString
                    $connection.Open()
                    $prId = "$(System.PullRequest.PullRequestId)"
                    $buildId = "$(Build.BuildId)"
                    $getRollbackCmd = $connection.CreateCommand()
                    $getRollbackCmd.CommandText = "SELECT rollback_script_name FROM Payroll.dbo.migration_rollback_mapper WHERE pr_id = @prId AND build_id = @buildId"
                    $getRollbackCmd.Parameters.AddWithValue("@prId", $prId) | Out-Null
                    $getRollbackCmd.Parameters.AddWithValue("@buildId", $buildId) | Out-Null
                    $reader = $getRollbackCmd.ExecuteReader()
                    $rollbackScripts = @()
                    while ($reader.Read()) 
                    {
                      $rollbackScripts += $reader["rollback_script_name"]
                    }
                    $reader.Close()
                    foreach ($rollbackFile in $rollbackScripts) {
                      $fileName = [System.IO.Path]::GetFileNameWithoutExtension($rollbackFile)
                      if ($fileName -match "^RB__V(\d+)__(.+)$") 
                      {
                        $version = $matches[1]
                        $feature = $matches[2]
                        $migrationScript = "V$version`__$feature.sql"
                        $migrationCmd = $connection.CreateCommand()
                        $migrationCmd.CommandText = "SELECT COUNT(1) FROM flyway_schema_history WHERE success = 1 AND version = @version AND script = @script"
                        $migrationCmd.Parameters.AddWithValue("@version", $version) | Out-Null
                        $migrationCmd.Parameters.AddWithValue("@script", $migrationScript) | Out-Null
                        $count = $migrationCmd.ExecuteScalar()
                        if ($count -gt 0) {
                          $updateCmd = $connection.CreateCommand()
                          $updateCmd.CommandText = "UPDATE Payroll.dbo.migration_rollback_mapper SET migration_version = @version, migration_script = @script WHERE pr_id = @prId AND build_id = @buildId AND rollback_script_name = @rollbackName"                        
                          $updateCmd.Parameters.AddWithValue("@version", $version) | Out-Null
                          $updateCmd.Parameters.AddWithValue("@script", $migrationScript) | Out-Null
                          $updateCmd.Parameters.AddWithValue("@prId", $prId) | Out-Null
                          $updateCmd.Parameters.AddWithValue("@buildId", $buildId) | Out-Null
                          $updateCmd.Parameters.AddWithValue("@rollbackName", $rollbackFile) | Out-Null
                          $updated = $updateCmd.ExecuteNonQuery()
                          Write-Host "Updated $updated record(s) for '$rollbackFile' with version '$version'"
                        } else {
                            Write-Host "No matching migration found for rollback script '$rollbackFile'"
                          }
                      } else {
                          Write-Host "Rollback script name '$fileName' does not match expected pattern 'RB__V<version>__<feature>.sql'"
                        }
                    }        
                    $connection.Close()
                } catch {
                    Write-Error "Error updating rollback mapper: $_"
                    if ($connection.State -eq 'Open') {
                      $connection.Close()
                    }
                    exit 1 
                  }
          env:
            dbUser: $(dbUser_1)
            dbPassword: $(dbPassword)
###################################################################
  - stage: Postmigration_Flyway_Validator
    dependsOn: Flyway_Migration
    condition: succeeded()
    displayName: "Post_Flyway_Validator"
    jobs:
      - job: PostFlyway_Validator
        steps:
          - task: PowerShell@2
            displayName: 'Flyway Validate (Post Migration Consistency Check)'
            inputs:
              targetType: 'inline'
              script: |
                $env:FLYWAY_USER = $env:dbUser
                $env:FLYWAY_PASSWORD = $env:dbPassword
                Write-Host "Validating Flyway consistency after migration."
                & flyway validate "-configFiles=$(FLYWAY_CONFIG_PATH)"
                if ($LASTEXITCODE -ne 0) {
                    Write-Error "Flyway validation failed. Database and scripts may be inconsistent!"
                    exit 1
                }
            env:
              dbUser: $(dbUser_1)
              dbPassword: $(dbPassword)
