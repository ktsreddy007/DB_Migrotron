trigger:
  branches:
    include:
      - main

pr: 
  branches:
    include:
     - main
  paths:
    include:
      - Database/MSSQL_Server/Dev/migrations/**
      - Database/MSSQL_Server/Dev/rollback_sql/**
      
pool:
  name: Self-Hosted   

variables:
  DB_SERVER: 'localhost'
  DB_NAME: 'Payroll'
  FLYWAY_CONFIG_PATH: '$(Build.SourcesDirectory)/Database/MSSQL_Server/Dev/conf/flyway-dev.conf' 
  REPO_URL: 'https://github.com/ktsreddy007/DB_Migrotron' 
  REPO_FOLDER: 'Database/MSSQL_Server/Dev/rollback_sql'
  LOG_FOLDER: 'B:/Pre_Post_SQL_Logs'
  LOG_FILE: '$(LOG_FOLDER)/Migration_Logs.txt'
  TABLES_FILE: '$(LOG_FOLDER)/Tables_list.txt'
  SQL_FLUFF_CONFIG: '$(Build.SourcesDirectory)/Database/MSSQL_Server/Dev/.sqlfluff'
  SQL_FLUFFS_REPORTS: 'B:/SQLFluff_Reports'
  SQL_FLUFF_OUTPUT_FILE: '$(SQL_FLUFFS_REPORTS)/sqlfluff_pr_$(System.PullRequest.PullRequestId).json'

stages:
  - stage: CaptureRollbackScripts
    displayName: 'Capture Rollback Scripts and Insert into Mapper Table'
    jobs:
      - job: RollbackScripts_Recorder
        steps:
          - checkout: none
          - template: Database/templates/checkout-sparse.yml  
          - task: PowerShell@2
            displayName: 'File Capture and Insertor'
            inputs:
              targetType: 'inline'
              script: |
                try {
                      $prId = "$(System.PullRequest.PullRequestId)"
                      if (-not $prId) {
                          Write-Host "PR ID not available. Exiting stage."
                          exit 0
                        }
                      Write-Host "PR ID detected: $prId"
                      $sourceBranch = "$(System.PullRequest.SourceBranch)"
                      $sourceBranchName = $sourceBranch -replace 'refs/heads/', ''
                      Write-Host "Source branch: $sourceBranchName"
                      git fetch origin +refs/heads/*:refs/remotes/origin/*
                      $changedFilesRaw = git diff --diff-filter=AMCR --name-only origin/main origin/$sourceBranchName
                      Write-Host "Raw changed files:`n$changedFilesRaw"
                      $changedFiles = $changedFilesRaw -split "`n" | Where-Object { $_ -ne "" }
                      Write-Host "Filtered changed files:`n$($changedFiles -join "`n")" 
                      if (-not $changedFiles -or $changedFiles.Count -eq 0) {
                            Write-Host "No changed files detected. Exiting."
                            exit 0
                      }
                      $rollbackScripts = $changedFiles | Where-Object { $_ -like "*Database/MSSQL_Server/Dev/rollback_sql/*.sql" }
                      Write-Host "Rollback scripts detected:`n$($rollbackScripts -join "`n")" 
                      if (-not $rollbackScripts -or $rollbackScripts.Count -eq 0) {
                            Write-Host "No rollback scripts found. Exiting job."
                            exit 0
                      }
                      Write-Host "Connecting to DB server: $(DB_SERVER), Database: $(DB_NAME)"      
                      [System.Reflection.Assembly]::LoadWithPartialName("System.Data.SqlClient") | Out-Null
                      $connectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$env:dbUser;Password=$env:dbPassword;"
                      $connection = New-Object System.Data.SqlClient.SqlConnection
                      $connection.ConnectionString = $connectionString
                      $connection.Open()
                      Write-Host "DB connection opened."
                      foreach ($scriptPath in $rollbackScripts) {
                          $scriptName = [System.IO.Path]::GetFileName($scriptPath)
                          Write-Host "Processing rollback script: $scriptName"
                          if ($scriptName -notmatch "^RB__V\d+__.+\.sql$") {
                              Write-Error "Rollback script '$scriptName' does not follow naming convention 'RB__V<version>__<name>.sql'."
                              exit 1
                          }
                          Write-Host "Inserting rollback script: $scriptName"    
                          $command = $connection.CreateCommand()
                          $command.CommandText = "INSERT INTO Payroll.dbo.migration_rollback_mapper (rollback_script_name, rollback_script_repo_folder, rollback_script_repo_url, build_id, pr_id) VALUES (@scriptName, @repoFolder, @repoUrl, @buildId, @prId)"
                          $command.Parameters.AddWithValue("@scriptName", $scriptName) | Out-Null
                          $command.Parameters.AddWithValue("@repoFolder", "$(REPO_FOLDER)") | Out-Null
                          $command.Parameters.AddWithValue("@repoUrl", "$(REPO_URL)") | Out-Null
                          $command.Parameters.AddWithValue("@buildId", "$(Build.BuildId)") | Out-Null
                          $command.Parameters.AddWithValue("@prId", $prId) | Out-Null
                          $command.ExecuteNonQuery()
                          Write-Host "Inserted into DB: $scriptName"
                    }
                    $connection.Close()
                } catch {
                    Write-Error "An error occurred: $_"
                    exit 1
                }      
            env:
                dbUser: $(dbUser_1)
                dbPassword: $(dbPassword)
###################################################################################
  - stage: PrepareEnvironment
    dependsOn: CaptureRollbackScripts
    condition: succeeded()
    displayName: 'Prepare Environment'
    jobs:
      - job: SetupTools
        steps:
          - task: PowerShell@2
            displayName: 'Check and Install Java (via command only)'
            inputs:
              targetType: 'inline'
              script: |
                if (Get-Command java -ErrorAction SilentlyContinue) {
                  Write-Host "Java is already installed."
                } else {
                  Write-Host "Java is NOT installed. Installing OpenJDK 11..."
                  choco install -y openjdk11
                }
          - task: PowerShell@2
            displayName: 'Check and Install Flyway CLI (any version)'
            inputs:
              targetType: 'inline'
              script: |
                if (Get-Command flyway -ErrorAction SilentlyContinue) {
                  Write-Host "Flyway CLI is already installed."
                } else {
                    Write-Host "Flyway CLI is NOT installed. Installing..."
                    $flywayZip = "$(Build.SourcesDirectory)\flyway.zip"
                    Invoke-WebRequest -Uri "https://repo1.maven.org/maven2/org/flywaydb/flyway-commandline/9.8.1/flyway-commandline-9.8.1-windows-x64.zip" -OutFile $flywayZip
                    Expand-Archive -Path $flywayZip -DestinationPath "$(Build.SourcesDirectory)\flyway"
                    $flywayPath = "$(Build.SourcesDirectory)\flyway\flyway-9.8.1"
                    $env:Path = "$flywayPath;$env:Path"
                    Write-Host "Flyway CLI installed successfully."
                  }
          - task: PowerShell@2
            displayName: 'Check and Install Python'
            inputs:
             targetType: 'inline'
             script: |
               $pythonPath = "C:\Program Files\Python313\python.exe"
               if (-Not (Test-Path $pythonPath)) {
                 Write-Error "Python not found at $pythonPath. Please install Python system-wide."
                  exit 1
                }
                Write-Host "Python found at $pythonPath"
               & "$pythonPath" --version
          - task: PowerShell@2
            displayName: 'Check and Install SQLFluff'
            inputs:
              targetType: 'inline'
              script: |
                $pythonPath = "C:\Program Files\Python313\python.exe"
                $sqlfluffPath = "C:\Program Files\Python313\Scripts\sqlfluff.exe"
                if (-Not (Test-Path $sqlfluffPath)) {
                  Write-Host "sqlfluff not found. Installing via pip..."
                  & "$pythonPath" -m pip install sqlfluff
                } else {
                    Write-Host "sqlfluff is already installed at $sqlfluffPath"
                  }
                Write-Host "sqlfluff version:"
                & "$sqlfluffPath" --version      
######################################################
  - stage: SQL_Linting
    displayName: "SQL_Syntax_Checker"
    dependsOn: PrepareEnvironment
    condition: succeeded()
    jobs:
     - job: Run_SQLFluff_Lint
       steps:
        - checkout: none
        - template: Database/templates/checkout-sparse.yml 
        - task: PowerShell@2
          displayName: "Run SQLFluff Lint"
          inputs:
            targetType: 'inline'
            script: |
              $sqlfluffPath = "C:\Program Files\Python313\Scripts\sqlfluff.exe"
              New-Item -ItemType Directory -Force -Path "$(SQL_FLUFFS_REPORTS)"
              git fetch origin $(System.PullRequest.TargetBranch)
              $diffFiles = git diff --name-only origin/$(System.PullRequest.TargetBranch) HEAD
              $changedFiles = @($diffFiles | Where-Object { $_.ToLower().EndsWith(".sql") })
              if ($changedFiles.Count -eq 0) {
                Write-Host "##[section]No SQL files changed in this PR. Skipping linting."
                Exit 0
              } 
              Write-Host "##[section]Changed SQL Files:"
              $changedFiles | ForEach-Object { Write-Host $_ }
              $jsonOutputFile = "$(SQL_FLUFF_OUTPUT_FILE)"
              $reportDir = Split-Path $jsonOutputFile -Parent
              New-Item -ItemType Directory -Force -Path $reportDir | Out-Null
              $lintErrors = 0
              foreach ($file in $changedFiles) {
                if (-Not (Test-Path $file)) {
                  Write-Host "Skipping non-existent file: $file"
                  continue
                }
                Write-Host "Linting file: $file"
                & "$sqlfluffPath" lint $file --config "$(SQL_FLUFF_CONFIG)" --format json | Out-File -Append -Encoding utf8 $jsonOutputFile
                if ($LASTEXITCODE -ne 0) {
                    $lintErrors++
                }
              }
              if ($lintErrors -gt 0) {
                  Write-Host "##vso[task.complete result=SucceededWithIssues;]SQLFluff found linting issues."
              } else {
                  Write-Host "##[section]SQLFluff: No linting issues found."
                }
              exit 0                          
######################################################
  - stage: Pre_FlywayValidator
    dependsOn: SQL_Linting
    condition: succeeded()
    displayName: 'Flyway Validate and Info'
    jobs:
      - job: ValidateFlyway
        steps:
          - checkout: none
          - template: Database/templates/checkout-sparse.yml 
          - task: PowerShell@2
            displayName: 'Conditional Flyway Validate (skip on fresh DB)'
            inputs:
              targetType: 'inline'
              script: |
                $env:FLYWAY_USER = $env:dbUser
                $env:FLYWAY_PASSWORD = $env:dbPassword

                $connectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$env:dbUser;Password=$env:dbPassword;"
                [System.Reflection.Assembly]::LoadWithPartialName("System.Data.SqlClient") | Out-Null
                $connection = New-Object System.Data.SqlClient.SqlConnection
                $connection.ConnectionString = $connectionString
                $connection.Open()
                $query = "SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'flyway_schema_history'"
                $command = $connection.CreateCommand()
                $command.CommandText = $query
                $tableExists = $command.ExecuteScalar()
                $connection.Close()
                Write-Host "Using Flyway config file at path: $(FLYWAY_CONFIG_PATH)"
                if ($tableExists -gt 0) {
                    Write-Host "flyway_schema_history table found. Proceeding with flyway validate."
                    & flyway validate "-ignoreMigrationPatterns=*:pending" "-configFiles=$(FLYWAY_CONFIG_PATH)"
                    if ($LASTEXITCODE -ne 0) {
                            Write-Error "Flyway validate failed."
                            exit 1
                    }
                } else {
                    Write-Host "flyway_schema_history table NOT found so Skiping flyway validate for fresh DB."
                } 
            env:
              dbUser: $(dbUser_1)
              dbPassword: $(dbPassword)     
          - task: PowerShell@2
            displayName: 'Flyway Info (Dry Run)'
            inputs:
              targetType: 'inline'
              script: |
                $env:FLYWAY_USER = $env:dbUser
                $env:FLYWAY_PASSWORD = $env:dbPassword

                Write-Host "Using Flyway config file at path: $(FLYWAY_CONFIG_PATH)"
                & flyway info "-configFiles=$(FLYWAY_CONFIG_PATH)"
                if ($LASTEXITCODE -ne 0) {
                      Write-Error "Flyway info command failed."
                      exit 1
                }
            env:
              dbUser: $(dbUser_1)
              dbPassword: $(dbPassword)  
###############################################################                            
  - stage: Premigration_SQLLogger
    displayName: "Pre_SQL_Logger"
    dependsOn: Pre_FlywayValidator 
    condition: succeeded()
    jobs:
     - job: PreSQL_Logger
       steps:
          - checkout: none
          - template: Database/templates/checkout-sparse.yml 
            persistCredentials: true
            fetchDepth: 0
          - task: PowerShell@2
            displayName: 'Pre-Migration Table Record Logger'
            inputs:
              targetType: 'inline'
              script: |
                $logFolder = "$(LOG_FOLDER)"
                $logFile = "$(LOG_FILE)"
                $tablesFile = "$(TABLES_FILE)"
                if (-not (Test-Path $logFolder)) {
                    New-Item -Path $logFolder -ItemType Directory | Out-Null
                }
                $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                $prId = "$(System.PullRequest.PullRequestId)"
                $sourceBranch = "$(System.PullRequest.SourceBranch)"
                Write-Host "SourceBranch: $sourceBranch"
                $sourceBranchName = $sourceBranch -replace 'refs/heads/', ''
                Write-Host "SourceBranchName: $sourceBranchName"
                git fetch origin
                $changedFilesRaw = git diff --diff-filter=AMCR --name-only origin/main origin/$sourceBranchName
                $changedFiles = $changedFilesRaw -split "`n" | Where-Object { $_ -like "*.sql" }
                $filteredFiles = $changedFiles | Where-Object { $_ -like "*Database/MSSQL_Server/Dev/migrations/*" }
                $filteredFiles | ForEach-Object { Write-Host " - $_" }

                $tableNames = @()
                foreach ($file in $filteredFiles) {
                        $fullPath = Join-Path -Path "$(Build.SourcesDirectory)" -ChildPath $file
                        if (Test-Path $fullPath) {
                            Write-Host "Processing file: $fullPath"
                            Add-Content -Path $logFile -Value "Processed migration script: $file"
                            $matches = Get-Content $fullPath |
                            Select-String -Pattern "(?i)(create\s+table|insert\s+into|alter\s+table)\s+((\[[^\]]+\]|\w+)\.)*((\[[^\]]+\]|\w+))" -AllMatches
                            foreach ($matchInfo in $matches) {
                                  foreach ($match in $matchInfo.Matches) {
                                      $fullMatch = $match.Value  
                                      $parts = $fullMatch -split '\.'
                                      $table = $parts[-1] -replace '\[|\]', ''
                                      if ($table -and -not ($tableNames -contains $table)) {
                                          $tableNames += $table
                                          Write-Host "  → Found table: $table"
                                      }
                                  }
                            }          
                        } else {
                            Write-Host "File not found: $fullPath"
                          }
                        }
                if ($tableNames.Count -eq 0) {
                      Write-Host "No tables extracted from migration files."
                    } else {
                    $tableNames | Out-File -FilePath $tablesFile -Encoding utf8
                }
                Add-Content -Path $logFile -Value "=====BEFORE MIGRATION RECORD COUNT====="
                Add-Content -Path $logFile -Value "RunID: $(Build.BuildId)"
                foreach ($table in $tableNames) {
                  try {
                        $schema = "dbo"
                        $tableName = $table
                        if ($table -match "^\[(.+?)\]\.\[(.+?)\]$") {
                            $schema = $matches[1]
                            $tableName = $matches[2]
                        } elseif ($table -match "^(.+?)\.(.+?)$") {
                            $schema = $matches[1]
                            $tableName = $matches[2]
                          }
                        $query = "IF OBJECT_ID('$schema.$tableName', 'U') IS NOT NULL SELECT COUNT(*) FROM [$schema].[$tableName] ELSE SELECT -1"
                        $connectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$env:dbUser;Password=$env:dbPassword;"
                        $connection = New-Object System.Data.SqlClient.SqlConnection($connectionString)
                        $command = $connection.CreateCommand()
                        $command.CommandText = $query
                        $connection.Open()
                        $count = $command.ExecuteScalar()
                        $connection.Close()
                        
                        if ($count -eq -1) {
                          Add-Content -Path $logFile -Value "TableName : $table"
                          Add-Content -Path $logFile -Value "RecordsCount : No Table / New Table"
                        } else {
                          Add-Content -Path $logFile -Value "TableName : $table"
                          Add-Content -Path $logFile -Value "RecordsCount : $count" 
                          }
                        Add-Content -Path $logFile -Value "Timestamp : $timestamp`n"
                        Write-Host "Table: $table | Records: $(if ($count -eq -1) {'No Table / New Table'} else {$count})"
                      } catch {
                          Write-Host "Unexpected error checking table [$table]: $($_.Exception.Message)"
                          Add-Content -Path $logFile -Value "TableName : $table"
                          Add-Content -Path $logFile -Value "RecordsCount : Error - $($_.Exception.Message)"
                          Add-Content -Path $logFile -Value "Timestamp : $timestamp`n"
                        }
                    }
                  Add-Content -Path $logFile -Value "======MIGRATION START ==============="
            env:
              dbUser: $(dbUser_1)
              dbPassword: $(dbPassword)       
#######################################################
  - stage: Rollback_Finder
    dependsOn: Premigration_SQLLogger
    condition: succeeded()
    displayName: "Rollback Scripts Existence"
    jobs:
      - job: RollbackCheck
        steps:
          - checkout: none
          - template: Database/templates/checkout-sparse.yml 
          - task: PowerShell@2
            displayName: 'Check if Rollback Script Exists for this PR'
            inputs:
                targetType: 'inline'
                script: |
                    $prId = "$(System.PullRequest.PullRequestId)"
                    Write-Host "Checking rollback scripts for PR ID: $prId"
                    $connectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$env:dbUser;Password=$env:dbPassword;"
                    [System.Reflection.Assembly]::LoadWithPartialName("System.Data.SqlClient") | Out-Null
                    $connection = New-Object System.Data.SqlClient.SqlConnection
                    $connection.ConnectionString = $connectionString
                    $connection.Open()
                    $query = "SELECT COUNT(*) FROM Payroll.dbo.migration_rollback_mapper WHERE pr_id = @prId AND rollback_script_name IS NOT NULL AND LTRIM(RTRIM(rollback_script_name)) <> ''"
                    $command = $connection.CreateCommand()
                    $command.CommandText = $query
                    $command.Parameters.AddWithValue("@prId", $prId) | Out-Null
                    $rollbackCount = $command.ExecuteScalar()
                    if ($rollbackCount -eq 0) {
                          Write-Host "No valid rollback scripts found for PR $prId. Failing pipeline."
                          $deleteCommand = $connection.CreateCommand()
                          $deleteQuery = "DELETE FROM Payroll.dbo.migration_rollback_mapper WHERE pr_id = @prId"
                          $deleteCommand.Parameters.AddWithValue("@prId", $prId) | Out-Null
                          $deleted = $deleteCommand.ExecuteNonQuery()
                          Write-Host "Deleted $deleted invalid rollback record(s) for PR ID $prId."
                          $connection.Close()
                          exit 1
                        } else {
                         Write-Host "Valid Rollback script(s) found: $rollbackCount for PR $prId. Proceeding to merge."
                         $connection.Close()
                    }
            env:
              dbUser: $(dbUser_1)
              dbPassword: $(dbPassword)
###############################################################             
  - stage: Flyway_Migration
    dependsOn: Rollback_Finder
    condition: succeeded()
    displayName: 'Migrating the Scripts'
    jobs:
      - deployment: FlywayMigrate
        environment: Go_Flyway
        strategy:
          runOnce:
            deploy: 
              steps:
                - checkout: none
                - template: Database/templates/checkout-sparse.yml
                - task: PowerShell@2
                  displayName: 'Flyway Migrate'
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Connecting to DB server: $(DB_SERVER), Database: $(DB_NAME)"
                      [System.Reflection.Assembly]::LoadWithPartialName("System.Data.SqlClient") | Out-Null
                      $dbUser = $env:dbUser
                      $dbPassword = $env:dbPassword
                      $env:FLYWAY_USER = $dbUser
                      $env:FLYWAY_PASSWORD = $dbPassword
                      $connectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$dbUser;Password=$dbPassword;"
                      $connection = New-Object System.Data.SqlClient.SqlConnection
                      $connection.ConnectionString = $connectionString
                      $connection.Open()
                      Write-Host "DB connection opened."
                      $tableName = "flyway_schema_history"
                      $sqlQuery = "SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = '$tableName'"
                      $command = $connection.CreateCommand()
                      $command.CommandText = $sqlQuery
                      $tableCount = $command.ExecuteScalar()
                      Write-Host "Table count result: $tableCount"    
                      if ($tableCount -eq 0) {
                          Write-Host "Table '$tableName' does not exist."
                          Write-Host "Running flyway baseline before migrate with baselineVersion=0..."
                          & flyway -configFiles="$(FLYWAY_CONFIG_PATH)" baseline -baselineVersion=0
                          if ($LASTEXITCODE -ne 0) {
                            Write-Error "Flyway baseline failed."
                            $connection.Close()
                            exit 1
                          }
                      }
                      else {
                        Write-Host "Table '$tableName' exists."
                      }
                      Write-Host "Flyway migrate triggered on merge/push to main branch."
                      & flyway -configFiles="$(FLYWAY_CONFIG_PATH)" migrate
                      if ($LASTEXITCODE -ne 0) {
                          Write-Error "Flyway migrate failed."
                          $connection.Close()
                          exit 1
                      }
                      Write-Host "Flyway migrate completed successfully."
                      $connection.Close()
                  env:
                    dbUser: $(dbUser_1)
                    dbPassword: $(dbPassword)
###################################################################
  - stage: Postmigration_SQLLogger
    displayName: "Post_SQL_Logger"
    dependsOn: Flyway_Migration
    condition: succeeded()
    jobs:
     - job: PostSQL_Logger
       steps:
         - task: PowerShell@2
           displayName: 'Post-Migration Table Record Logger'
           inputs:
              targetType: 'inline'
              script: |
                $logFile = "$(LOG_FILE)"
                $tablesFile = "$(TABLES_FILE)"
                $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                Write-Host "Starting Post-Migration Logging..."
                if (-Not (Test-Path $tablesFile)) {
                    Write-Error "UsedTables.txt not found. Cannot continue."
                    exit 1
                }
                Add-Content -Path $logFile -Value "=====AFTER MIGRATION RECORD COUNT====="
                Add-Content -Path $logFile -Value "RunID: $(Build.BuildId)"
                $tableNames = Get-Content $tablesFile | Sort-Object -Unique
                foreach ($table in $tableNames) {
                    try {
                        $query = "SELECT COUNT(*) FROM [$table]"
                        $connectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$env:dbUser;Password=$env:dbPassword;"
                        $connection = New-Object System.Data.SqlClient.SqlConnection($connectionString)
                        $command = $connection.CreateCommand()
                        $command.CommandText = $query
                        $connection.Open()
                        $count = $command.ExecuteScalar()
                        $connection.Close()
                        Add-Content -Path $logFile -Value "TableName : $table"
                        Add-Content -Path $logFile -Value "RecordsCount : $count"
                        Add-Content -Path $logFile -Value "Timestamp : $timestamp`n"
                        Write-Host "Table: $table | Records: $count"
                      } catch {
                        Add-Content -Path $logFile -Value "TableName : $table"
                        Add-Content -Path $logFile -Value "RecordsCount : No Table / New Table"
                        Add-Content -Path $logFile -Value "Timestamp : $timestamp`n"
                        Write-Host "Table [$table] does not exist after migration."
                      }
                    }
                Add-Content -Path $logFile -Value "=========MIGRATION COMPLETE =========`n"
                Write-Host "Post-Migration Logging Completed."
           env:
             dbUser: $(dbUser_1)
             dbPassword: $(dbPassword)
###################################################################
  - stage: Mappertb_updater
    displayName: "Migration_Rollback_Updater"
    dependsOn: Flyway_Migration
    condition: succeeded()
    jobs:
     - job: Updating_Mapper_Table
       steps:
        - checkout: none
        - template: Database/templates/checkout-sparse.yml
        - task: PowerShell@2
          displayName: 'Update Migration Version and Script in Mapper Table'
          inputs:
              targetType: 'inline'
              script: |
                try {
                    $connectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$env:dbUser;Password=$env:dbPassword;"
                    [System.Reflection.Assembly]::LoadWithPartialName("System.Data.SqlClient") | Out-Null
                    $connection = New-Object System.Data.SqlClient.SqlConnection
                    $connection.ConnectionString = $connectionString
                    $connection.Open()
                    $prId = "$(System.PullRequest.PullRequestId)"
                    $buildId = "$(Build.BuildId)"
                    $getRollbackCmd = $connection.CreateCommand()
                    $getRollbackCmd.CommandText = "SELECT rollback_script_name FROM Payroll.dbo.migration_rollback_mapper WHERE pr_id = @prId AND build_id = @buildId"
                    $getRollbackCmd.Parameters.AddWithValue("@prId", $prId) | Out-Null
                    $getRollbackCmd.Parameters.AddWithValue("@buildId", $buildId) | Out-Null
                    $reader = $getRollbackCmd.ExecuteReader()
                    $rollbackScripts = @()
                    while ($reader.Read()) 
                    {
                      $rollbackScripts += $reader["rollback_script_name"]
                    }
                    $reader.Close()
                    foreach ($rollbackFile in $rollbackScripts) {
                      $fileName = [System.IO.Path]::GetFileNameWithoutExtension($rollbackFile)
                      if ($fileName -match "^RB__V(\d+)__(.+)$") 
                      {
                        $version = $matches[1]
                        $feature = $matches[2]
                        $migrationScript = "V$version`__$feature.sql"
                        $migrationCmd = $connection.CreateCommand()
                        $migrationCmd.CommandText = "SELECT COUNT(1) FROM flyway_schema_history WHERE success = 1 AND version = @version AND script = @script"
                        $migrationCmd.Parameters.AddWithValue("@version", $version) | Out-Null
                        $migrationCmd.Parameters.AddWithValue("@script", $migrationScript) | Out-Null
                        $count = $migrationCmd.ExecuteScalar()
                        if ($count -gt 0) {
                          $updateCmd = $connection.CreateCommand()
                          $updateCmd.CommandText = "UPDATE Payroll.dbo.migration_rollback_mapper SET migration_version = @version, migration_script = @script WHERE pr_id = @prId AND build_id = @buildId AND rollback_script_name = @rollbackName"                        
                          $updateCmd.Parameters.AddWithValue("@version", $version) | Out-Null
                          $updateCmd.Parameters.AddWithValue("@script", $migrationScript) | Out-Null
                          $updateCmd.Parameters.AddWithValue("@prId", $prId) | Out-Null
                          $updateCmd.Parameters.AddWithValue("@buildId", $buildId) | Out-Null
                          $updateCmd.Parameters.AddWithValue("@rollbackName", $rollbackFile) | Out-Null
                          $updated = $updateCmd.ExecuteNonQuery()
                          Write-Host "Updated $updated record(s) for '$rollbackFile' with version '$version'"
                        } else {
                            Write-Host "No matching migration found for rollback script '$rollbackFile'"
                          }
                      } else {
                          Write-Host "Rollback script name '$fileName' does not match expected pattern 'RB__V<version>__<feature>.sql'"
                        }
                    }        
                    $connection.Close()
                } catch {
                    Write-Error "Error updating rollback mapper: $_"
                    if ($connection.State -eq 'Open') {
                      $connection.Close()
                    }
                    exit 1 
                  }
          env:
            dbUser: $(dbUser_1)
            dbPassword: $(dbPassword)
###################################################################
  - stage: Postmigration_Flyway_Validator
    dependsOn: Flyway_Migration
    condition: succeeded()
    displayName: "Post_Flyway_Validator"
    jobs:
      - job: PostFlyway_Validator
        steps:
          - checkout: none
          - template: Database/templates/checkout-sparse.yml
          - task: PowerShell@2
            displayName: 'Flyway Validate (Post Migration Consistency Check)'
            inputs:
              targetType: 'inline'
              script: |
                $env:FLYWAY_USER = $env:dbUser
                $env:FLYWAY_PASSWORD = $env:dbPassword
                Write-Host "Validating Flyway consistency after migration."
                & flyway validate "-configFiles=$(FLYWAY_CONFIG_PATH)"
                if ($LASTEXITCODE -ne 0) {
                    Write-Error "Flyway validation failed. Database and scripts may be inconsistent!"
                    exit 1
                }
            env:
              dbUser: $(dbUser_1)
              dbPassword: $(dbPassword)